(this.webpackJsonptaba=this.webpackJsonptaba||[]).push([[0],{101:function(t,e,o){t.exports=o(114)},106:function(t,e){},113:function(t,e,o){},114:function(t,e,o){"use strict";o.r(e);var n=o(5),a=o.n(n),i=o(81),s=o.n(i),r=o(54),l=o.n(r),c=o(39),d=o(86),g=o(65),u=o(124);const h={position:"absolute",pointerEvents:"none",zIndex:1,background:"#125",color:"#fff",fontSize:9,borderRadius:4,padding:5,maxWidth:300,maxHeight:300,overflow:"hidden",boxShadow:"2px 2px 4px #ccc"},p={flows:{scheme:u.a[u.a.length-1].slice().reverse()}};class m extends a.a.Component{constructor(t){super(t),this.state={tooltip:void 0},this.initialViewState=void 0,this.handleViewStateChange=t=>{const e=this.props.onViewStateChange;e&&e(t);this.state.tooltip&&this.setState({tooltip:void 0})},this.handleHighlight=(t,e)=>{e||this.setState({tooltip:void 0}),this.setState({})},this.initialViewState={latitude:-41.235726,longitude:172.5118422,zoom:5,bearing:0,pitch:0}}renderTooltip(){const t=this.state.tooltip;if(!t)return null;const e=t.object,o=t.x,n=t.y;return e?a.a.createElement("pre",{style:Object(d.a)({},h,{left:o,top:n})},JSON.stringify(e,null,2)):null}render(){const t=this.props,e=t.flows,o=t.locations,n=t.getLocationId,i=t.getLocationCentroid,s=t.getFlowMagnitude;return a.a.createElement(a.a.Fragment,null,a.a.createElement(g.c,{pickable:!0,initialViewState:this.initialViewState,showTotals:!0,colors:p,flows:e,locations:o,mapStyle:"mapbox://styles/mapbox/dark-v10",animate:!0,opacity:1,mixBlendMode:"screen",mapboxAccessToken:"pk.eyJ1IjoibnlvdTA0NSIsImEiOiJjaXJ6bDYxeWcwMXRzMnlwa2tmbzduNmd0In0.gLrTUpqhS3PYYy_AtCp4Gw",getLocationId:n,getLocationCentroid:i,getFlowMagnitude:s,onViewStateChange:this.handleViewStateChange,onHighlighted:this.handleHighlight}),a.a.createElement(g.a,{bottom:35,right:10},a.a.createElement(g.b,{colors:p}),a.a.createElement("div",{className:"source"},"Source: ",a.a.createElement("a",{href:"https://datafinder.stats.govt.nz/table/104720-2018-census-main-means-of-travel-to-work-by-statistical-area-2/data/"},"Stats NZ"))),this.renderTooltip())}}function w(t,e){var o;if("undefined"===typeof Symbol||null==t[Symbol.iterator]){if(Array.isArray(t)||(o=function(t,e){if(!t)return;if("string"===typeof t)return f(t,e);var o=Object.prototype.toString.call(t).slice(8,-1);"Object"===o&&t.constructor&&(o=t.constructor.name);if("Map"===o||"Set"===o)return Array.from(t);if("Arguments"===o||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(o))return f(t,e)}(t))||e&&t&&"number"===typeof t.length){o&&(t=o);var n=0,a=function(){};return{s:a,n:function(){return n>=t.length?{done:!0}:{done:!1,value:t[n++]}},e:function(t){throw t},f:a}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var i,s=!0,r=!1;return{s:function(){o=t[Symbol.iterator]()},n:function(){var t=o.next();return s=t.done,t},e:function(t){r=!0,i=t},f:function(){try{s||null==o.return||o.return()}finally{if(r)throw i}}}}function f(t,e){(null==e||e>t.length)&&(e=t.length);for(var o=0,n=new Array(e);o<e;o++)n[o]=t[o];return n}class b extends a.a.Component{constructor(t){super(t),this.clusterIndex=void 0,this.aggregateFlowsByZoom=void 0,this.handleViewStateChange=t=>{const e=this.clusterIndex.availableZoomLevels,o=t.zoom;var n=c.c(e,o);14===n&&(n=13),this.setState({clusteredLocations:this.clusterIndex.getClusterNodesFor(n),aggregateFlows:this.aggregateFlowsByZoom.get(n)})};const e=this.props,o=e.flows,n=e.getLocationId,a=e.getLocationCentroid,i=e.getFlowOriginId,s=e.getFlowDestId,r=e.getFlowMagnitude;let l;const d=this.props.locations;if(this.props.clusterLevels)l=this.props.clusterLevels;else{const t=c.e(o,{getFlowOriginId:i,getFlowDestId:s,getFlowMagnitude:r});l=c.b(d,{getLocationId:n,getLocationCentroid:a},t,{makeClusterName:(t,e)=>"Cluster #".concat(t," of ").concat(e," locations")})}const g=c.a(l),u=new Map;var h,p=w(g.availableZoomLevels);try{for(p.s();!(h=p.n()).done;){const t=h.value;u.set(t,g.aggregateFlows(o,t,{getFlowOriginId:i,getFlowDestId:s,getFlowMagnitude:r}))}}catch(f){p.e(f)}finally{p.f()}const m=Math.max.apply(null,g.availableZoomLevels);this.clusterIndex=g,this.aggregateFlowsByZoom=u,this.state={clusteredLocations:this.clusterIndex.getClusterNodesFor(m),aggregateFlows:this.aggregateFlowsByZoom.get(m)}}render(){const t=this.props,e=t.getFlowOriginId,o=t.getFlowDestId,n=t.getFlowMagnitude,i=this.state,s=i.clusteredLocations,r=i.aggregateFlows;return s&&r?a.a.createElement(m,{locations:s,flows:r,getLocationId:t=>t.id,getLocationCentroid:t=>t.centroid,getFlowOriginId:t=>c.d(t)?t.origin:e(t),getFlowDestId:t=>c.d(t)?t.dest:o(t),getFlowMagnitude:t=>c.d(t)?t.count:n(t),onViewStateChange:this.handleViewStateChange}):null}}var v=b;o(113);l.a.parsePromise=function(t){return new Promise((function(e,o){l.a.parse(t,{download:!0,header:!0,dynamicTyping:!0,skipEmptyLines:!0,complete:e,error:o})}))};class y extends n.Component{constructor(...t){super(...t),this.state={locations:null,flows:null,time:0}}componentDidMount(){Promise.all([l.a.parsePromise("https://neon-ninja.github.io/TABA/travel.csv"),l.a.parsePromise("https://neon-ninja.github.io/TABA/sa2_centroids.csv")]).then(([t,e])=>{console.log(t,e,this.state),this.setState({flows:t.data,locations:e.data})})}render(){const t=this.state,e=t.locations,o=t.flows;return e&&o?a.a.createElement(v,{locations:e,flows:o,getLocationId:t=>t.code,getLocationCentroid:t=>[t.longitude,t.latitude],getFlowOriginId:t=>t.home_SA2,getFlowDestId:t=>t.work_SA2,getFlowMagnitude:t=>t.Total}):null}}s.a.render(a.a.createElement(y,null),document.getElementById("root")),document.write('<a href="https://github.com/neon-ninja/TABA">\n    <img \n      style="position: absolute; top: 0; right: 0; border: 0;" \n      src="https://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png" \n      alt="Fork me on GitHub">\n   </a>\n ')},69:function(t,e){}},[[101,1,2]]]);
//# sourceMappingURL=main.4f5de25b.chunk.js.map